/*
 * Navit, a modular navigation system.
 * Copyright (C) 2005-2009 Navit Team
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 */

/**
 * @file location.c
 *
 * @brief Logic to work with location data.
 *
 * A location contains data describing the movement of the vehicle, along with associated metadata.
 * It may have been obtained directly from a source such as GPS or nearby networks, or calculated by
 * various other means.
 *
 * @date 2015-11-30
 * @author mvglasow
 */

#include <math.h>
#include <glib.h>
#include "config.h"
#include "debug.h"
#include "item.h"
#include "coord.h"
#include "transform.h"
#include "callback.h"
#include "location.h"


/**
 * @brief Obtains the effective preference level of a location.
 *
 * The effective preference level is determined by applying a penalty, based on the location's validity,
 * to its base preference level. The result can be used for direct integer comparison.
 *
 * @param plev The preference level of the location, see {@code enum preference}
 * @param valid The validity of the location, see {@code enum attr_position_valid}
 *
 * @return The effective preference level (-INT_MAX for an invalid location)
 */
int
get_effective_preference_level(int plev, int valid) {
	switch (valid) {
		case attr_position_valid_invalid:
			return -INT_MAX;
		case attr_position_valid_valid:
		case attr_position_valid_static:
			return plev;
		case attr_position_valid_extrapolated_spatial:
			return plev - 1;
		default:
		/*case attr_position_valid_extrapolated_time:*/
			return plev - 2;
	}
}


/**
 * @brief Updates the vehicle position.
 *
 * This method recalculates the position and sets its members accordingly. It is generally called from
 * the position callback but may be extended in the future to be called by other triggers (events or timers)
 * to extrapolate the current vehicle position.
 *
 * The new location is generated by fusing information from the supplied sources together. For now, this
 * function simply takes the most recent valid fix it received.
 *
 * This function will fill the struct passed as {@code out} with the newly calculated location data and
 * trigger callbacks from the list passed as {@code cbl} when one of the respective attributes changes.
 * The decision whether to trigger a callback is made by comparing old and new values of {@code out}. In
 * order for this to work correctly, {@code out} must hold the last location of the vehicle when this
 * method is called, or zeroed out if no previous location is known.
 *
 * If {@code out} supplies a position, its {@code fix_type}, {@code fix_time}, {@code fixiso8601},
 * {@code valid} and {@code preference} members will be taken from the input locations which were used
 * to determine that position, selecting the best fix type, most recent timestamp, best validity and
 * highest preference level. If no position is supplied, all locations which were used to obtain at
 * least one value of the output location will be searched for this information in the same manner.
 *
 * This function is intended to be called approximately once per second (the refresh rate of most GPS
 * devices found in the market) for each location source, with the number of input locations in the
 * order of magnitude of 1 - 10 (put differently, at most 31 different locations). Any future extensions
 * to this function should consider these parameters.
 *
 * @param v The {@code struct_vehicle_priv} for the vehicle
 * @param in Raw locations (NULL-terminated pointer array)
 * @param out The last calculated location of the vehicle; this struct will receive the updated location
 * @param cbl Callback list of the vehicle; callbacks from this list will be triggered when one of the
 * respective attributes changes
 */
/* FIXME: use Kalman filter for speed, bearing and altitude (requires accuracy for each) */
void
vehicle_update_position(struct location ** in, struct location * out, struct callback_list * cbl) {
	int i, i_eplev, used;
	int fix_type_changed = 0;					/* Whether the fix type has changed. */
	int qual_changed = 0;						/* Whether position quality (number of sats) has changed. */
	int sats_used_changed = 0;					/* Whether the number of sats used has changed. */
	int coord_geo_changed = 0;					/* Whether the position has changed. */
	int valid_changed = 0;						/* Whether position validity has changed. */
	int geo_eplev = -INT_MAX;					/* Effective preference level for position */
	int speed_eplev = -INT_MAX;					/* Effective preference level for speed */
	int direction_eplev = -INT_MAX;				/* Effective preference level for bearing */
	int height_eplev = -INT_MAX;				/* Effective preference level for altitude */
	int geo_count = 0;							/* Number of eligible positions */
	int direction_count = 0;					/* Number of eligible bearings */
	struct coord_geo_cart cart = {0, 0, 0};		/* Cartesian coordinates used to average between positions (result) */
	struct coord_geo_cart cart_i;				/* Cartesian coordinates used to average between positions (input) */
	navit_float geo_k = 0, geo_p = 0;			/* Weight and covariance for Kalman filter */
	navit_float geo_len;						/* Length of Cartesian vector for positions */
	struct location * tmp = g_new0(struct location, 1);	/* Temporary storage for the new location */
	navit_float weight_i;						/* Weight for current location (inverse of radius) */
	navit_float speed_weight = 0;				/* Total weight for speed */
	navit_float direction_weight;				/* Total weight for bearing */
	navit_float height_weight = 0;				/* Total weight for elevation */
	navit_float dirx = 0, diry = 0;				/* Cartesian coordinates used to average between bearings */
	time_t t;									/* Temporary time for formatting */
	struct tm *tm;								/* Temporary time for formatting */

	dbg(lvl_debug, "enter\n");

	/* First pass: determine best preference level for data and set some metadata */
	for (i = 0; in[i]; i++) {
		i_eplev = get_effective_preference_level(in[i]->preference, in[i]->valid);
		/* ignore if eplev is -INT_MAX */
		if (i_eplev == -INT_MAX)
			continue;
		if (in[i]->flags & location_flag_has_geo) {
			if (i_eplev > geo_eplev) {
				geo_eplev = i_eplev;
				geo_count = 1;
				tmp->fix_type = in[i]->fix_type;
				tmp->fix_time.tv_sec = in[i]->fix_time.tv_sec;
				tmp->fix_time.tv_usec = in[i]->fix_time.tv_usec;
				tmp->valid = in[i]->valid;
				tmp->preference = in[i]->preference;
			} else if (i_eplev == geo_eplev) {
				geo_count++;
				if (in[i]->fix_type > tmp->fix_type)
					tmp->fix_type = in[i]->fix_type;
				if (timercmp(&(in[i]->fix_time), &(tmp->fix_time), >)) {
					tmp->fix_time.tv_sec = in[i]->fix_time.tv_sec;
					tmp->fix_time.tv_usec = in[i]->fix_time.tv_usec;
				}
				if (attr_position_valid_comp(in[i]->valid, tmp->valid) > 0)
					tmp->valid = in[i]->valid;
				if (in[i]->preference > tmp->preference)
					tmp->preference = in[i]->preference;
			}
		}
		if ((i_eplev > speed_eplev) && (in[i]->flags & location_flag_has_speed))
			speed_eplev = i_eplev;
		if (in[i]->flags & location_flag_has_direction) {
			if (i_eplev > direction_eplev) {
				direction_eplev = i_eplev;
				direction_count = 1;
			} else if (i_eplev == direction_eplev)
				direction_count++;
		}
		if ((i_eplev > height_eplev) && (in[i]->flags & location_flag_has_height))
			height_eplev = i_eplev;
	}

	dbg(lvl_debug, "found %d locations, %d of which will be used for position data\n", i, geo_count);

	for (i = 0; in[i]; i++) {
		i_eplev = get_effective_preference_level(in[i]->preference, in[i]->valid);
		/* ignore if eplev is -INT_MAX */
		if (i_eplev == -INT_MAX)
			continue;
		used = 0;
		weight_i = 1.0 / in[i]->radius;
		if ((in[i]->flags & location_flag_has_geo) && (i_eplev == geo_eplev)) {
			dbg(lvl_debug, "using position data from index %d\n", i);
			used = 1;
			if (geo_count == 1) {
				/* Skip expensive averaging if we have just one position */
				tmp->geo.lat = in[i]->geo.lat;
				tmp->geo.lng = in[i]->geo.lng;
				tmp->radius = in[i]->radius;
				tmp->flags |= location_flag_has_geo;
			} else if (geo_count > 1) {
				if (geo_p == 0) {
					/* first round: use first value as initial estimate */
					geo_p = in[i]->radius * in[i]->radius;
					/* For simplification, assume a unit sphere for Cartesian coords */
					transform_geo_to_cart(&(in[i]->geo), 1, 1, &cart);
				} else {
					geo_k = geo_p / (geo_p + in[i]->radius * in[i]->radius);
					geo_p *= (1.0 - geo_k);
					transform_geo_to_cart(&(in[i]->geo), 1, 1, &cart_i);
					cart.x = (1.0 - geo_k) * cart.x + geo_k * cart_i.x;
					cart.y = (1.0 - geo_k) * cart.y + geo_k * cart_i.y;
					cart.z = (1.0 - geo_k) * cart.z + geo_k * cart_i.z;
				}
			}
		}
		if ((in[i]->flags & location_flag_has_speed) && (i_eplev == speed_eplev)) {
			used = 1;
			speed_weight += weight_i;
			tmp->speed += in[i]->speed * weight_i;
		}
		if ((in[i]->flags & location_flag_has_direction) && (i_eplev == direction_eplev)) {
			used = 1;
			if (direction_count == 1) {
				/* Skip averaging if we have just one bearing */
				tmp->direction = in[i]->direction;
				tmp->flags |= location_flag_has_direction;
			} else if (direction_count > 1) {
				/* Sum up Cartesian coords, using weight as radius */
				dirx += weight_i * navit_cos(in[i]->direction);
				diry += weight_i * navit_sin(in[i]->direction);
			}
		}
		if ((in[i]->flags & location_flag_has_height) && (i_eplev == height_eplev)) {
			used = 1;
			height_weight += weight_i;
			tmp->height += in[i]->height * weight_i;
		}
		if (used) {
			if (!geo_count) {
				/* set fix type, time, validity and preference if we had no locations to collect them from */
				if (in[i]->fix_type > tmp->fix_type)
					tmp->fix_type = in[i]->fix_type;
				if (timercmp(&(in[i]->fix_time), &(tmp->fix_time), >)) {
					tmp->fix_time.tv_sec = in[i]->fix_time.tv_sec;
					tmp->fix_time.tv_usec = in[i]->fix_time.tv_usec;
				}
				if (attr_position_valid_comp(in[i]->valid, tmp->valid) > 0)
					tmp->valid = in[i]->valid;
				if (in[i]->preference > tmp->preference)
					tmp->preference = in[i]->preference;
			}
			if (in[i]->flags & location_flag_has_sat_data) {
				tmp->sats = in[i]->sats;
				tmp->sats_used = in[i]->sats_used;
				tmp->flags |= location_flag_has_sat_data;
			}
		}
	}

	/* Note that we're not setting tmp->timeiso8601 here, it will be generated from scratch as we copy
	 * tmp to out. */

	if (geo_count > 1) {
		/* convert Cartesian vector back to lat/lon, using its length as radius */
		geo_len = sqrtf(cart.x * cart.x + cart.y * cart.y + cart.z * cart.z);
		if (geo_len > 0) {
			/* TODO this has a potentially expensive iteration, can we rewrite the func for our special case? */
			transform_cart_to_geo(&cart, geo_len, geo_len, &(tmp->geo));
			tmp->radius = sqrtf(geo_p);
			tmp->flags |= location_flag_has_geo;
		} else
			/* TODO: should we reuse the old position with an appropriate validity in this case? */
			dbg(lvl_error, "can't update position: input positions cancel each other out\n");
	}
	if (speed_weight != 0) {
		tmp->speed /= speed_weight;
		tmp->flags |= location_flag_has_speed;
	}
	if (direction_count > 1) {
		direction_weight = sqrtf(dirx + dirx + diry + diry);
		if (direction_weight > 0) {
			if (diry >= 0)
				tmp->direction = navit_acos(dirx / direction_weight);
			else
				tmp->direction = 360.0 - navit_acos(dirx / direction_weight);
			/* TODO: do we need to normalize the angle to a particular range? */
			tmp->flags |= location_flag_has_direction;
		} else
			/* TODO: should we reuse the old bearing in that case? */
			dbg(lvl_error, "can't update direction: input directions cancel each other out\n");
	}
	if (height_weight != 0) {
		tmp->height /= height_weight;
		tmp->flags |= location_flag_has_height;
	}

	/* copy tmp to out */
	if ((out->geo.lat != tmp->geo.lat) || (out->geo.lng != tmp->geo.lng)) {
		coord_geo_changed = 1;
		out->geo.lat = tmp->geo.lat;
		out->geo.lng = tmp->geo.lng;
	}
	out->speed = tmp->speed;
	out->direction = tmp->direction;
	out->height = tmp->height;
	out->radius = tmp->radius;
	if (out->fix_type != tmp->fix_type) {
		fix_type_changed = 1;
		out->fix_type = tmp->fix_type;
	}
	if ((out->fix_time.tv_sec != tmp->fix_time.tv_sec) || (out->fix_time.tv_usec != tmp->fix_time.tv_usec)) {
		out->fix_time.tv_sec = tmp->fix_time.tv_sec;
		out->fix_time.tv_usec = tmp->fix_time.tv_usec;
		t = out->fix_time.tv_sec;
		tm = gmtime(&t);
		strftime(out->fixiso8601, sizeof(out->fixiso8601), "%Y-%m-%dT%TZ", tm);
	}
	if (out->sats != tmp->sats) {
		qual_changed = 1;
		out->sats = tmp->sats;
	}
	if (out->sats_used != tmp->sats_used) {
		sats_used_changed = 1;
		out->sats_used = tmp->sats_used;
	}
	if (out->valid != tmp->valid) {
		valid_changed = 1;
		out->valid = tmp->valid;
	}
	out->flags = tmp->flags;

	if (valid_changed || fix_type_changed || qual_changed || sats_used_changed || coord_geo_changed) {
		dbg(lvl_debug, "Attributes changed:%s%s%s%s%s\n",
				valid_changed ? " position_valid" : "",
				coord_geo_changed ? " position_coord_geo" : "",
				fix_type_changed ? " position_fix_type ": "",
				qual_changed ? " position_qual" : "",
				sats_used_changed ? " position_sats_used" : "");
	} else {
		dbg(lvl_debug, "No attributes changed\n");
	}

	/* Trigger callbacks only after we've fully updated the location */
	if (valid_changed)
		callback_list_call_attr_0(cbl, attr_position_valid);
	if (out->valid == attr_position_valid_invalid)
		return;
	if (fix_type_changed)
		callback_list_call_attr_0(cbl, attr_position_fix_type);
	if (qual_changed)
		callback_list_call_attr_0(cbl, attr_position_qual);
	if (sats_used_changed)
		callback_list_call_attr_0(cbl, attr_position_sats_used);
	if (coord_geo_changed)
		callback_list_call_attr_0(cbl, attr_position_coord_geo);
	dbg(lvl_debug, "lat %f lon %f time %s\n", out->geo.lat, out->geo.lng, out->fixiso8601);
}


